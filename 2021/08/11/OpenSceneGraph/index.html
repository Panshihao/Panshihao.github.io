<!DOCTYPE html>

<html lang="en" class="no-js" id="body">

	<!-- BEGIN HEAD -->
<head>

  
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  

  <title>OpenSceneGraph</title>

  

  <meta name="description" content="">

  


  <link rel="shortcut icon" href="/img/favicon.ico" type="image/png">

  

<!-- Open Graph data-->
<meta property="og:type" content="blog">
<meta property="og:title" content="OpenSceneGraph">
<meta property="og:site_name" content="Shen Tongda">
<meta property="og:url" content="http://www.shentongda.net/2021/08/11/OpenSceneGraph/">
<meta property="og:description" content="">



  
  <meta property="og:image" content="http://www.shentongda.net/img/background.jpg">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:image:width" content="2400">
  <meta property="og:image:height" content="1254">
  
  
  
  <meta property="og:image" content="http://www.shentongda.net/img/small_background.jpg">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:image:width" content="200">
  <meta property="og:image:height" content="105">
  
  


<!-- end Open Graph data-->
  
<link href="https://fonts.googleapis.com/css?family=Hind:300,400,500,600,700" rel="stylesheet" type="text/css">
  
<!-- GLOBAL MANDATORY STYLES -->
<link href="/vendor/simple-line-icons/css/simple-line-icons.css" rel="stylesheet" type="text/css"/>
<link href="/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css"/>
<link href="/vendor/animate.css/animate.css" rel="stylesheet">



<link rel="stylesheet" href="/sass/layout.css">

  



<meta name="generator" content="Hexo 5.4.1"></head>
<!-- END HEAD -->

  <body>
		
		


<!--========== HEADER ==========-->
<header class="header navbar-fixed-top">
  <!-- Navbar -->
  <nav class="navbar" role="navigation">
      <div class="container">
          <!-- Brand and toggle get grouped for better mobile display -->
          <div class="menu-container js_nav-item">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="toggle-icon"></span>
              </button>

              <!-- Logo -->
              <div class="logo">
                <!-- En caso de una text -->
                
                    <a class="logo-wrap" href="/#body" style="text-decoration: none;" >
                        <img class="logo-img logo-img-main" src="img/logo-bg.png" alt="Logo">
                        <img class="logo-img logo-img-active" src="img/logo.png" alt="Logo">
                    </a>
                
              </div>
              <!-- End Logo -->
          </div>

          <!-- Collect the nav links, forms, and other content for toggling -->
          <div class="collapse navbar-collapse nav-collapse">
              <div class="menu-container">
                  <ul class="nav navbar-nav navbar-nav-right">
                      
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#body"
                            >
                            Home
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#intro"
                            >
                            Intro
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#education"
                            >
                            Education
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#academic"
                            >
                            Academic
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#awards"
                            >
                            Awards
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#interests"
                            >
                            Interests
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#daily"
                            >
                            Daily
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/blog/"
                            >
                            Blog
                        </a>
                        </li>
                      
                        <li class="js_nav-item nav-item">
                            <a  class="nav-item-child nav-item-hover"
                                href="/#contact"
                            >
                            Contact
                        </a>
                        </li>
                      
                  </ul>
              </div>
          </div>
          <!-- End Navbar Collapse -->
      </div>
  </nav>
  <!-- Navbar -->

</header>
<!--========== END HEADER ==========-->

		<section id="post">
  <div class="container content content-width">
    <h1 class="post-title"> OpenSceneGraph</h1>
    <p class="date"> Wed Aug 11 2021 01:00:05 GMT+0800 </p>
    
    <h1 id="视口显示"><a href="#视口显示" class="headerlink" title="视口显示"></a>视口显示</h1><p>osgViewer 库包含了一系列用于控制视口显示的相关类，并封装了大量用户常用的功能函数，例如显示管理、事件响应、场景渲染等；提供了对 DatabasePager 的支持；还可以针对同一场景图形，提供并通过多个独立的视口显示该场景。</p>
<p>osgViewer 库使用 osgCamera 类来管理 OpenGL 的模型-视图矩阵。另外还包含 SimpleViewer、Viewer 和 CompositeViewer 三个视口类。</p>
<h2 id="Viewer-类"><a href="#Viewer-类" class="headerlink" title="Viewer 类"></a>Viewer 类</h2><p>Viewer 类在内部创建了一个 osg::Camera 摄像机对象来管理 OSG 的模型-视图矩阵，用户可以通过以下方法来控制 Camera 对象：</p>
<ul>
<li><p>将摄像机操作器关联到 Viewer 中。默认状态下 Viewer::run()将自动创建一个 osgGA::TrackballManipulator 对象来控制摄像机。osgGA 库定义了一些常用的控制器类，用户可以调用 Viewer::setCameraManipulator()来指定一个期望的控制器；</p>
</li>
<li><p>设置 Camera 对象的投影矩阵和观察矩阵为自定义的矩阵值，可以保证用户程序能够完全控制视口的浏览动作。可以在 while 循环中执行以下操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( !viewer.<span class="built_in">done</span>() )</span><br><span class="line">&#123;</span><br><span class="line">    viewer.<span class="built_in">getCamera</span>()-&gt;<span class="built_in">setViewMatrix</span>( m );</span><br><span class="line">    viewer.<span class="built_in">frame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述两个操作是互斥的，如果直接设置 Camera 对象的矩阵值，就不能使用 Viewer::run()函数，因为该函数不允许每帧都实时改变视口的参数。</p>
<p>除了设置视口外，Viewer 类的 Camera 对象还提供了设置清屏颜色、清除深度缓存的颜色缓存的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewer.<span class="built_in">getCamera</span>()-&gt;<span class="built_in">setClearColor</span>( osg::<span class="built_in">Vec4</span>() );</span><br><span class="line"></span><br><span class="line">viewer.<span class="built_in">getCamera</span>()-&gt;<span class="built_in">setClearMask</span>( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );</span><br></pre></td></tr></table></figure>

<p>上面的代码设置设置了清屏的颜色，并清除了颜色、深度和模板缓存。</p>
<h2 id="SimpleViewer-和-CompositeViewer"><a href="#SimpleViewer-和-CompositeViewer" class="headerlink" title="SimpleViewer 和 CompositeViewer"></a>SimpleViewer 和 CompositeViewer</h2><p>SimpleViewer 类不会主动创建窗口或者设备的上下文，需要用户程序来创建窗口和设备上下文。用于将已有的程序移植到 OSG 环境中，是一个可以和现有程序框架相配合的简单的视口类。</p>
<p>Viewer 类只能在一个场景中添加一个视口（也可以使用一组摄像机拼接一个视口，用于支持多通道渲染），CompositeViewer 类可以支持一个或多个场景的多个视口显示，并允许用户程序指定渲染顺序。</p>
<p>CompositeViewer 可以支持渲染到纹理（render-to-texture, RTT）的操作，即允许用户程序将一个视口中渲染的图像作为另一个视口的纹理贴图。</p>
<h1 id="更改与回调"><a href="#更改与回调" class="headerlink" title="更改与回调"></a>更改与回调</h1><p>OSG 允许用户对场景进数据行动态修改。OSG 在拣选（cull）遍历中关联了渲染图形中的几何数据和渲染状态信息，它们将在绘制（draw）遍历中进行处理。osgViewer 库支持多线程模式，每一个线程均独立地运行拣选及绘制遍历。出于性能优化考虑，OSG 并没有为了线程的安全性增设内存锁，而是要求用户程序在拣选以及绘制遍历之外的时间对场景图形进行修改。</p>
<p>有几种方法可以确保用户的修改不会与拣选以及绘制线程发生冲突。最容易想到的方法是在 Viewer::frame()调用时添加锁，禁止加锁时对场景图形进行修改，但这需要在主渲染循环中添加额外代码。如果希望程序更加整洁和规范的话，可以选择在更新遍历中进行场景的修改。</p>
<h2 id="数据变度"><a href="#数据变度" class="headerlink" title="数据变度"></a>数据变度</h2><p>osgViewer 支持的多线程模型允许用户程序主循环不必等到绘制遍历结束就可以继续运行，即上一帧画面的 Viewer::frame()方法可能与下一帧的更新遍历产生重叠。在开发动态场景图形时，此类问题容易造成系统崩溃。</p>
<p>OSG 提供了 osg::Object::DataVariance()方法用于解决这一问题。初始状态下，Object 对象的数据变度是 UNSPECIFIED。用户可以调用 Object 对象的 setDataVariance()方法将数据变度修改为 STATIC 或 DYNAMIC。OSG 将确保绘制遍历在所有的 DYNAMIC 节点和数据处理完之后才会返回。</p>
<p>例如，静态场景中根节点有两个叶子节点：一个坐标变换之后保持静止，一个保持旋转。此时应该将根节点和保持静止的 MatrixTransform 节点设置为 STATIC，把旋转的物体设置为 DYNAMIC。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[Group : STATIC] --&gt; |keepStill | B[ MatrixTransform : STATIC ]</span><br><span class="line"></span><br><span class="line">A[Group : STATIC] --&gt; |NodeCallback Rotate| C[ MatrixTransform : DYNAMIC ]</span><br><span class="line"></span><br><span class="line">B --&gt; D[model.osg]</span><br><span class="line">C --&gt; D[model.osg]</span><br></pre></td></tr></table></figure>

<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>OSG 中可以设置更新回调和事件回调，事件回调发生于键盘、鼠标、窗口等交互过程中，更新回调发生于每一帧的系统遍历过程中。</p>
<p>其中更新回调允许用户设置 Node 和 Drawable 对象的回调类。Node 可以在执行 ==更新和拣选== 遍历时进行更新回调，而 Drawable 可以在==拣选和绘制==遍历时进行更新回调。通常在更新遍历中使用 osg::NodeCallback 接口对 Node 进行动态修改。</p>
<p>回调基类 NodeCallback 接口的使用方法如下：</p>
<ul>
<li>从 NodeCallback 继承一个新的类；</li>
<li>重载 NodeCallback::operator()方法，使用该方法来实现场景图形的动态更改；</li>
<li>将用户从 NodeCallback 继承的类实例化，然后使用 Node::setUpdateCallback()、Node::setDrawCallback()、Node::setEventCallback()等方法关联到将要修改的 Node。<br /></li>
</ul>
<p>在每个更新遍历过程中，都会调用派生类中的 operator()方法，从而允许用户程序对 Node 进行修改。</p>
<p>OSG 向 operator()方法传递了两个参数：</p>
<ul>
<li>回调类所关联的 Node 的地址，即用户在 operator()方法中将要更改的 Node 节点地址；</li>
<li>osg::NodeVisitor 对象的地址；<br /></li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RotateCB</span> : <span class="keyword">public</span> osg::NodeCallback</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(osg::Node* node, osg::NodeVisitor* nv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">dynamic_cast</span>&lt;&gt;(node);</span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//遍历场景图中的其它节点，执行更新回调</span></span><br><span class="line">        <span class="built_in">traverse</span>(node, nv);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">double</span> _angle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node-&gt;<span class="built_in">setUpdateCallback</span>( <span class="keyword">new</span> RotateCB );</span><br><span class="line">node-&gt;<span class="built_in">addUpdateCallback</span>( <span class="keyword">new</span> ... );<span class="comment">//防止覆盖回调列表中的第一个回调函数</span></span><br></pre></td></tr></table></figure>

<p>NodeCallback 类间接继承自 Referenced，用户程序不需要维护 RotateCB 指针，Node 类内部维护了一个更新回调的 ref_ptr&lt;&gt; 指针列表（设置多个回调用 addUpdateCallback），当 RotateCB 的引用计数减为 0 时将自动释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[node_n] --&gt; |NodeVisitor_apply| B[node_n+1]</span><br><span class="line">B --&gt; |NodeVisitor_apply| B1[node_...]</span><br><span class="line">A1[node_...] --&gt; |NodeVisitor_apply| A</span><br><span class="line"></span><br><span class="line">A --&gt; C[ ref_ptr NodeCallback operator ]</span><br><span class="line">B --&gt; D[ ref_ptr NodeCallback operator ]</span><br></pre></td></tr></table></figure>

<h2 id="EventCallback"><a href="#EventCallback" class="headerlink" title="EventCallback"></a>EventCallback</h2><p>EventCallback 也派生自 NodeCallback，例如，可以给相机添加一个事件回调：viewer-&gt;getCamera()-&gt;setEventCallback(); 在事件回调中可以处理键盘或鼠标事件。类似于向 viewer 中添加 EventHandler。</p>
<h1 id="NodeVisitor-类"><a href="#NodeVisitor-类" class="headerlink" title="NodeVisitor 类"></a>NodeVisitor 类</h1><p>NodeVisitro 类是 OSG 对于访问器设计思想的具体实现。从本质上说，NodeVisitor 类遍历了一个场景图形并为每一个被访问节点调用特定的函数。这一技术是许多操作的基类，例如：osgUtil::Optimizer, osgUtil 库中的几何处理类；文件输出类。其中如前所述，OSG 使用 osgUtil::UpdateVisitor 类（继承自 NodeVisitor）来实现更新遍历。</p>
<p>NodeVisitor 类是一个基类，用户程序无法直接实例化。可以使用提供的任何 NodeVisitor 派生类，也可以使用自己编写的继承自 NodeVisitor 类的代码。</p>
<p>NodeVisitor 类包含了一些经过重载的 apply()方法，其输入参数涵盖了大部分 OSG 的节点类型。当一个 NodeVisitor 对象遍历整个场景图形时，它将会为每个被访问的节点调用其相应的 apply()方法。</p>
<p>OSG 中 NodeVisitor 类采用==访问器==这一设计模式实现：每一种数据元素节点都可以通过 accept()方法调用访问器；访问器则通过 apply()方法获取传入的节点对象，并执行所需的节点操作。上述过程被称为“双重派发”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Node::accept</span><span class="params">(NodeVisitor&amp; nv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nv.<span class="built_in">apply</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺省情况下，NodeVisitor 基类禁止执行遍历。因此在派生类中，需要使用枚举量 NodeVisitor::TRAVERSE_ALL_CHILDREN 来初始化基类，以允许执行遍历。否则，OSG 将不会调用用户的 apply()方法。示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FindNamedNode</span> : <span class="keyword">public</span> osg::NodeVisitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FindNamedNode</span>( <span class="type">const</span> std::string&amp; name ) : osg::<span class="built_in">NodeVisitor</span>( osg::NodeVisitor::TRAVERSE_ALL_CHILDREN ), _name( name )&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">apply</span><span class="params">( osg::Node&amp; node )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( node.<span class="built_in">getName</span>() == _name )</span><br><span class="line">            _node = &amp;node;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">traverse</span>( node );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">osg::Node* <span class="title">getNode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _node.<span class="built_in">get</span>(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">    osg::ref_ptr&lt;osg::Node&gt; _node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用程序中遍历整个场景图形时，可以将 NodeVisitor 作为 Node::accept()的输入参数传递。用户可以在任何一个节点上调用 accept()， NodeVisitor 将从那个节点开始遍历整个场景图形。也可以从根节点调用 accept()，对整个场景图形进行搜索。</p>
<h1 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h1><p>OSG 主要使用 osgGA 库来处理用户交互，GA 的全称是 GUI Abstraction。</p>
<h2 id="事件和动作适配器"><a href="#事件和动作适配器" class="headerlink" title="事件和动作适配器"></a>事件和动作适配器</h2><p>GUIEventAdapter 类是不同操作系统底层交互事件与 OSG 交互事件的适配接口。其中定义了很多枚举值，表示了常见视窗操作系统中的鼠标、键盘、触摸板的操作。</p>
<p>交互事件类型可以使用 getEventType() 获取；键盘按键值可以进一步使用 getKey() 获取，鼠标的位置可以进一步使用 getX()、getY()、getXnormalized()、getYnormalized() 获取，前者返回实际的窗口坐标，后者返回以窗口中心点为[0,0]，规范至[-1,1]的鼠标坐标。</p>
<p>GUIActionAdapter 类用于适配 OSG 应用程序向不同操作系统传递的动作请求，该类的内容较为简单。</p>
<h2 id="事件队列与事件处理器"><a href="#事件队列与事件处理器" class="headerlink" title="事件队列与事件处理器"></a>事件队列与事件处理器</h2><p>对于所有传递给场景的键盘、鼠标等输入设备时间，可以使用 EventQueue 来记录，并使用 GUIEventHandler 及其派生类将事件传递给用户进行处理。</p>
<p>EventQueue 类可以理解为一个交互事件的集合，它保存了一个 GUIEventAdapter 队列，并提供了向队列新增元素的方法。</p>
<p>GUIEventHandler 是 OSG 键盘和鼠标交互事件的处理终端，GUIEventHandler 提供了可扩展的虚函数 handle()，通过类的派生和重构，即可实现用户自定义的交互事件处理工具。</p>
<p><img src="image-20200726002138241.png" alt="image-20200726002138241"></p>
<p>osgGA 中还提供了新的访问器 osgGA::EventVisitor 类，它作为场景访问的主要执行者，负责区分和调用各个节点、可绘制体以及渲染状态集的事件回调对象。</p>
<p>GUIEventHandler 类派生自节点回调类 NodeCallback 和可绘制体回调类 Drawable::EventCallback，因此它可以作为回调对象，使用 Node::setEventCallback 或者 Drawable::setEventCallback 设置给场景中的节点或可绘制体。回调的执行操作符 operator() 或者 event() 函数则会自动判断当前访问器是否为事件访问器 EventVisitor。若 handle 函数返回 true，则事件处理完毕，不会继续被其它事件处理器处理。</p>
<h2 id="漫游器与拖曳器"><a href="#漫游器与拖曳器" class="headerlink" title="漫游器与拖曳器"></a>漫游器与拖曳器</h2><p>在 OSG 场景中，用户与场景的主要交互方式有相机漫游和物体操控两种，分别可用漫游器和拖曳器实现。</p>
<p>通过 Viewer 对象的 setCameraManipulator 可以为视景器设置不同的漫游器。OSG 中的漫游器种类很多，主要有以下几种：</p>
<table>
<thead>
<tr>
<th align="center">漫游器名称</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">osgGA::TrackballManipulator</td>
<td align="center">轨迹球漫游器主要处理鼠标交互下视觉运动的平滑和准确性，不考虑物理规律</td>
</tr>
<tr>
<td align="center">DriveManipulator、FlightManipulator 和 UFOManipulator</td>
<td align="center">用于模拟操纵交通工具时的漫游效果</td>
</tr>
<tr>
<td align="center">AnimationPathManipulator</td>
<td align="center">沿固定路径的动态漫游</td>
</tr>
<tr>
<td align="center">NodeTrackerManipulator</td>
<td align="center">跟随场景中的物体进行漫游</td>
</tr>
<tr>
<td align="center">CameraViewManipulator</td>
<td align="center">可以切换相机视角的漫游器工具</td>
</tr>
<tr>
<td align="center">KeySwitchMatrixManipulator</td>
<td align="center">可以进行多个漫游器切换</td>
</tr>
<tr>
<td align="center">TerrainManipulator</td>
<td align="center">用于在大规模地形上进行浏览的漫游器</td>
</tr>
</tbody></table>
<p>拖曳器（Dragger）的目的是通过操控模型的 MatrixTransform 父节点来实现操控模型的外观。为了将拖曳器与模型分离，OSG 中使用了命令设计模式进行了封装，拖曳相关的类有：osgManipulator::MotionCommand 类、osgManipulator::CommandManager 类。</p>
<p>命令类 MotionCommand 类可用于命令的执行、管理命令的作用对象、获取命令的执行阶段等。CommandManager 类主要用于绑定拖曳器及其作用对象，一个拖曳器可以同时绑定操控多个对象。</p>
<p>使用拖曳器的具体流程如下：</p>
<ul>
<li>新建一种类型的拖曳器，并指定作为备选对象的节点；</li>
<li>将拖曳器和一个或多个备选对象进行绑定；</li>
<li>当用户执行交互动作时，信息首先反映到 Dragger::handle() 函数中，并生成相应的运动命令；</li>
<li>在接收者的接受函数中，完成拖曳器对备选对象的操控。<br /></li>
</ul>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>大多数的 3D 程序都需要某种形式的用户选择功能，终端用户可以交互地选择当前画面的某部分。用户选择的最简单形式为：用户将鼠标移动到场景中特定的位置，并点击鼠标；程序内部进行运算，将 2D 的鼠标 XY 坐标位置映射到正确的 3D 场景图形节点上，并保存节点地址以便将来使用。</p>
<p>从本质上说，OSG 程序通过两个步骤来实现用户选择：</p>
<ul>
<li>接收鼠标事件。osgGA 库提供了允许程序接受鼠标事件的事件类，且具有平台无关特性。</li>
<li>判断场景图形的哪个部分被鼠标光标覆盖。osgUtil 库提供了一种相交集类，可以在鼠标 XY 坐标的周围创建包围盒，并判断包围盒与场景图形的相交情况。osgUtil 将按照由前至后的顺序返回与包围盒相交的节点列表。<br /></li>
</ul>
<h3 id="捕获鼠标事件"><a href="#捕获鼠标事件" class="headerlink" title="捕获鼠标事件"></a>捕获鼠标事件</h3><p>在 OSG 中，osgGA::TrackballManipulator 可以实现视口矩阵的控制。TrackballManipulator 将鼠标事件作为输入，用于控制用户视口的 osg::Camera 视口矩阵。TrackballManipulator 派生自 osgGA::GUIEventHandler 类。GUIEventHandler 是虚基类，无法直接被实例化，用户程序可以从 GUIEventHandler 派生自己的类，以实现各种基于 GUI 事件的操作。</p>
<p><img src="image-20200726002138241.png" alt="image-20200726002138241"></p>
<p>例如要实现鼠标控制的选择操作，可以从 GUIEventHandler 派生新的类并重载 GUIEventHandler::handle() 方法，以接收鼠标事件；在程序中创建新类的实例并将其关联到应用程序的观察视口。handle()方法有两个输入参数：osgGA::GUIEventAdapter 和 osgGA::GUIActionAdapter。</p>
<ul>
<li>osgGA::GUIEventAdapter：<br>用户实现的 handle()可以接收来自 GUIEventAdaptor 的各种 GUI 事件，包括鼠标事件。GUIEventAdaptor 类的头文件中定义了枚举类型 EventType，使用 GUIEventAdapter::getEventType()方法可以得到当前的事件类型，用户程序可以从中选择自己需要的 GUI 事件，例如鼠标事件。<br><img src="image-20200726001922079.png" alt="image-20200726001922079"></li>
<li>osgGA::GUIActionAdapter:<br>GUIActionAdapter 是用户程序返回给 GUI 系统的程序接口。当遇到鼠标选择的操作时，用户将用于选择事件的 GUIEventHandler 关联到视口类，则视口类就是一个 GUIActionAdapter。用户需要使用它来实现当前视口与场景之间的交互。<br><img src="image-20200726001715703.png" alt="image-20200726001715703"></li>
</ul>
<p>在渲染视口之前，用户往往创建一个 GUIEventHandler 派生类的实例，并使用 Viewer::addEventHandler()方法将其关联到视口，一个视口可以有多个事件器，Viewer 类将 GUIEventHandler 对象添加到一个事件处理器列表中。程序运行时 Viewer 将调用每个 GUI 事件处理器的 handle()函数，直到其中一个的 handle()函数返回 true 为止。若用户返回 false，则将对其它事件处理器进行继续扫描。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PickHandler</span>:<span class="keyword">public</span> osgGA::GUIEventHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PickHandler</span>() : _mX(<span class="number">.0</span>), _mY(<span class="number">.0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">handle</span><span class="params">( <span class="type">const</span> osgGA::GUIEventAdapter&amp; ea, osgGA::GUIActionAdapter&amp; aa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        osgViewer::Viewer* viewer = <span class="built_in">dynamic_cast</span>&lt;osgViewer::Viewer*&gt;( &amp;aa );</span><br><span class="line">        <span class="keyword">if</span>(!viewer)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//继续遍历其它事件处理器</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span>( ea.<span class="built_in">getEventType</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> osgGA::GUIEventAdapter::PUSH:</span><br><span class="line">            <span class="keyword">case</span> osgGA::GUIEventAdapter::MOVE:</span><br><span class="line">                &#123;</span><br><span class="line">                    _mX = ea.<span class="built_in">getX</span>();</span><br><span class="line">                    _mY = ea.<span class="built_in">getY</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			   &#125;</span><br><span class="line">            <span class="keyword">case</span> osgGA::GUIEventAdapter::RELEASE:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//若按下按键之后没有移动，则在释放的时候处理</span></span><br><span class="line">                    <span class="keyword">if</span>( _mX==ea.<span class="built_in">getX</span>() &amp;&amp; _mY==ea.<span class="built_in">getY</span>() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>( <span class="built_in">pick</span>( ea.<span class="built_in">getXnormalized</span>(), ea.<span class="built_in">getYnormalized</span>(), viewer) )</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _mX, _mY;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pick</span><span class="params">( <span class="type">const</span> <span class="type">double</span> x, <span class="type">const</span> <span class="type">double</span> y, osgViewer::Viewer* viewer )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!viewer-&gt;<span class="built_in">getSceneData</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">w</span><span class="params">(<span class="number">.05</span>)</span>, <span class="title">h</span><span class="params">(<span class="number">.05</span>)</span></span>;</span><br><span class="line">        <span class="comment">//得到鼠标位置附近封闭多面体与场景的交点</span></span><br><span class="line">        osgUtil::PolytopeIntersector* picker = <span class="keyword">new</span> osgUtil::<span class="built_in">PolytopeIntersector</span>( osgUtil::Intersector::PROJECTION, x-w, y-h, x+w, y+h );</span><br><span class="line">        <span class="comment">//找出交点</span></span><br><span class="line">        <span class="function">osgUtil::IntersectionVisitor <span class="title">iv</span><span class="params">( picker )</span></span>;</span><br><span class="line">        <span class="comment">//从相机节点开始遍历场景中的Node</span></span><br><span class="line">        viewer-&gt;<span class="built_in">getCamera</span>()-&gt;<span class="built_in">accept</span>(iv);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(picker-&gt;<span class="built_in">containsIntersections</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            osg::NodePath&amp; nodePath = picker-&gt;<span class="built_in">getFirstIntersection</span>().nodePath;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> idx = nodePath.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(idx--)</span><br><span class="line">            &#123;</span><br><span class="line">                osg::MatrixTransfrom* mt = <span class="built_in">dynamic_cast</span>&lt;osg::MatrixTransform*&gt; (nodePath[idx]);</span><br><span class="line">                <span class="keyword">if</span>(mt == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(_selectedNode.<span class="built_in">valid</span>())</span><br><span class="line">                    <span class="comment">//清除节点的回调函数</span></span><br><span class="line">                    _selectedNode-&gt;<span class="built_in">setUpdateCallback</span>(<span class="literal">NULL</span>);</span><br><span class="line">                </span><br><span class="line">                _selectedNode = mt;</span><br><span class="line">                <span class="comment">//给节点添加自动旋转回调</span></span><br><span class="line">                _selectedNode-&gt;<span class="built_in">setUpdateCallback</span>( <span class="keyword">new</span> RotateCB );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!_selectedNode.<span class="built_in">valid</span>())</span><br><span class="line">                osg::<span class="built_in">notify</span>()&lt;&lt;<span class="string">&quot;pick failed.&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(_selectedNode.<span class="built_in">valid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            _selectedNode-&gt;<span class="built_in">setUpdateCallback</span>(<span class="literal">NULL</span>);</span><br><span class="line">            _selectedNode = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _selectedNode.<span class="built_in">valid</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，要实现接收鼠标事件并实现用户选择的功能，需要经过以下步骤：</p>
<ul>
<li>从 GUIEventHandler 继承新的类，重载 handle()方法；</li>
<li>在 handle()中，检查 GUIEventAdapter 参数传递的时间类型，并针对需要的事件类型执行相应的操作。方法返回 true 时将阻止其它事件处理器继续接收事件消息；</li>
<li>在渲染之前，创建事件处理器类的实例，并使用 addEventHandler()方法添加到视口中。OSG 将会把视口作为 GUIActionAdapter 参数传递给 handle()方法。<br /></li>
</ul>
<p>上述方法并不局限于使用鼠标进行选择。用户程序可以尝试实现与 TrackballManipulator 类相似的接收鼠标事件的类，可以接收键盘事件并实现对按键的响应操作。</p>
<h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><p>可以将通过点击鼠标进行节点选择想象成是从鼠标光标位置向场景中发射了一条射线。被鼠标选中的场景部分将与射线有一个交集。如果场景是由线和点元素组成的，那么射线的交运算可能无法符合用户的实际选择，因为鼠标的位置几乎无法与这些图元产生精确的空间交集。此外，在典型的透视渲染中，射线交运算的精度将与观察者所处的距离成反比。</p>
<p>OSG 使用一种名为多胞体（polytopo）的金字塔形包围盒代替射线，以克服上述问题。这种金字塔形的顶峰位于视点，中心轴直接穿过鼠标光标的位置。它距离视点的宽度是由视场和程序控制的参数决定的。</p>
<p>OSG 使用场景图形的自顶向下的继承结构，从而避免了 OpenGL 普遍存在的“迟钝”的选择特性，而在本地 CPU 上进行高效的计算。osgUtil::IntersectionVisitor 类继承自 NodeVisitor，它可以检测每个定点的包围盒与交集包围盒的关系，并允许在某个子图形不可能存在有交集的子节点时，跳过该子图形的遍历。</p>
<p>用户可以设置 IntersectionVisitor 类并使用几种不同的几何结构进行交集检测，例如平面和线段。其构造函数使用 osgUtil::Intersector 作为输入参数，Intersector 类定义了选择操作的几何体并执行实际的交集测试。</p>
<p>Intersector 是一个纯虚基类，用户程序无法将其实例化，而 osgUtil 库从 Intersector 派生了一些代表不同几何结构的新类，例如 osgUtil::PolytopeIntersector，也就是前文所述的、较为理想的鼠标点选判定模型。</p>
<p>有些程序需要拾取单独的顶点和多边形；而有些程序只需要简单地获取那些包含了被选节点的 Group 或 Transform 父节点。IntersectionVisitor 返回的 osg::NodePath 对象满足了这些要求。NodePath 是一个 std::vector&lt; osg::Node &gt; 向量，它表示沿着从根节点到叶节点的、呈现一定排列层次的节点路线。如果用户程序需要获取中间的 Group 组节点，只需要从后向前搜索满足程序要求的节点即可。</p>
<p>综上所述，要实现 OSG 中的鼠标选择操作，需要按照如下的步骤编写代码：</p>
<ul>
<li>创建并设置 PolytopeIntersector，其中的鼠标位置应当使用 GUIEventAdapter 中归一化的数据（ ea.getXnormalized(), ea.getYnormalized() ）；</li>
<li>创建 IntersectionVisitor 对象，并将 PolytopeIntersector 作为其构造函数的输入参数；</li>
<li>由场景图形的根节点加载 IntersectionVisitor，一般来说是通过 Viewer 中的 Camera 对象；</li>
<li>如果 PolytopeIntersector 的返回值包含了交集，那么可以获取返回的 NodePath 并搜索符合要求的节点。<br /></li>
</ul>
<h1 id="显示中文"><a href="#显示中文" class="headerlink" title="显示中文"></a>显示中文</h1><p>OSG 中可以绘制 2D 文字和 3D 文字。二维文字的表达工具为 osgText::Text 类，它派生自 osg::Drawable 类，对 drawImplementation() 进行了重构；三维文字使用 osgText::Text3D 类进行表达，Text3D 类多了 setCharacterDepth() 函数。示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">osg::ref_ptr&lt;osgText::Text3D&gt; text = <span class="keyword">new</span> osgText::Text3D;</span><br><span class="line"></span><br><span class="line">text-&gt;<span class="built_in">setFont</span>(<span class="string">&quot;fonts/arial.ttf&quot;</span>);</span><br><span class="line">text-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">text-&gt;<span class="built_in">setCharacterDepth</span>(<span class="number">10.0</span>);</span><br><span class="line">geode-&gt;<span class="built_in">addDrawable</span>(text);</span><br></pre></td></tr></table></figure>

<h2 id="字符编码格式"><a href="#字符编码格式" class="headerlink" title="字符编码格式"></a>字符编码格式</h2><p>为了能够显示世界各国的语言文字的编码的储存需求，在 ASCII 码表的基础上衍生出了许多字符编码格式：</p>
<table>
<thead>
<tr>
<th align="center">字符编码名称</th>
<th align="left">编码内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GB2312</td>
<td align="left">由中国国家标准总局于 1980 年颁布，采用双字节表达一个字符。共收录 6763 个汉字字符和 682 个其他语种字符，基本涵盖了中国大陆语言文字。</td>
</tr>
<tr>
<td align="center">BIG5</td>
<td align="left">大五码，是繁体中文汉字编码的早期通用标准。采用双字节表达一个字符，共收录了 13060 个中文字符，主要应用于中国台湾、香港等地区。</td>
</tr>
<tr>
<td align="center">GB18030</td>
<td align="left">由中国国家标准总局于 2000 年颁布。使用单字节、双字节和四字节 3 种变长编码格式表达字符编码，共收录了 70244 个汉字字符和大量其他语种字符，是目前最为全面的汉字编码方案。</td>
</tr>
<tr>
<td align="center">Unicode（UCS）</td>
<td align="left">由国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。</td>
</tr>
<tr>
<td align="center">UTF</td>
<td align="left">是 Unicode 编码到程序数据的转换方式（ UCS Transformtion Format ），常见的转换方式包括 UTF-8、UTF-16 等。</td>
</tr>
</tbody></table>
<p>为了使程序语言除了 ASCII 字符外能支持上述字符，C/C++ 语言中定义了“多字节字符”和“宽字符”的概念。多字节字符的字节数目可能不等，进行文本处理较为困难，适用于将文字存储为文件。宽字符类型（ wchar_t ）的一个值就代表一个 Unicode 字符，更利于对字符串进行统一的处理和操作。</p>
<p>在 OSG 中，osgText::String 类提供了 Unicode 编码的保存和显示功能，具体使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置为中国本地的编码格式</span></span><br><span class="line"><span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;.936&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;你好，世界！&quot;</span>;</span><br><span class="line"><span class="type">int</span> requiredSize = <span class="built_in">mbstowcs</span>( <span class="literal">NULL</span>, text, <span class="number">0</span> );</span><br><span class="line"><span class="type">wchar_t</span>* wtext = <span class="keyword">new</span> <span class="type">wchar_t</span>[requiredSize + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">mbstowcs</span>( wtext, text, requiredSize+<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">textDrawable-&gt;<span class="built_in">setText</span>(wtext);</span><br><span class="line"><span class="comment">//textDrawable-&gt;setText(L&quot;你好，世界！&quot;);</span></span><br><span class="line"></span><br><span class="line">osgText::Font* font = osgText::<span class="built_in">readFontFile</span>(<span class="string">&quot;Fonts/simhei.ttf&quot;</span>);</span><br><span class="line"></span><br><span class="line">textDrawable-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">textDrawable-&gt;<span class="built_in">setCharacterSize</span>( <span class="number">10.0</span> );</span><br><span class="line">textDrawable-&gt;<span class="built_in">setPositon</span>(osg::<span class="built_in">Vec3</span>());</span><br><span class="line">textDrawable-&gt;<span class="built_in">setColor</span>(osg::<span class="built_in">Vec4</span>());</span><br><span class="line">textDrawable-&gt;<span class="built_in">setAlignment</span>(osgText::Text::CENTER_BOTTOM);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组。</span></span><br><span class="line"><span class="comment">//该函数返回转换的字符数，不包括结尾的空字符。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mbstowcs</span><span class="params">(<span class="type">schar_t</span> *pwcs, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//pwcs -- 指向一个 wchar_t 元素的数组，数组长度足以存储一个最大字符长度的宽字符串;</span></span></span><br><span class="line"><span class="function"><span class="comment">//str -- 要被转换的多字节字符字符串;</span></span></span><br><span class="line"><span class="function"><span class="comment">//n -- 要被转换的最大字符数。</span></span></span><br></pre></td></tr></table></figure>

<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="场景动画"><a href="#场景动画" class="headerlink" title="场景动画"></a>场景动画</h2><p>在 OSG 中使用单独的 osgAnimation 库定义了一系列场景动画的相关功能类。构建场景对象动画的过程可以理解为定义和记录关键帧，以及在运行时自动计算中间帧并赋予物体的过程。用户自定义 osg::AnimationUpdateCallback 类，通过注册和使用更新回调来实现动画更新。用户还可以仅仅通过路径关键点来创建一些简单的路径动画。</p>
<p>关键帧是场景中角色或物体运动中关键动作所处的那一帧；关键帧之间的帧通过计算自动插值生成，称为过渡帧或中间帧，常见的插值方法有线性插值、球面线性插值和三次贝塞尔曲线插值；保存所需的关键帧，用于计算中间帧的工具称为采样器。</p>
<p><img src="image-20200803195742292.png" alt="image-20200803195742292"></p>
<p>关键帧容器派生自 std::vector，是一个模板类。一个关键帧容器只能容纳一种类型的关键帧；一个采样器必须使用同一种类型的关键帧容器和插值器。动画频道提供了一种集中管理采样器和动画对象的接口。</p>
<p>在有的场景中需要对多个动画效果进行混合。例如，一辆汽车行驶过程中撞到了物体，然后在空中翻滚前进。上述过程中需要分别建立平移动画（vec3）和旋转动画（Quat 四元数），这些动画根据关键帧类型不同，各自需要一个频道表示。osgAnimation 库中的 Animation 类就提供了这些功能。</p>
<p>动画的播放方式有 4 种：</p>
<table>
<thead>
<tr>
<th align="center">播放方式</th>
<th align="center">播放效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ONCE</td>
<td align="center">播放一次之后停止</td>
</tr>
<tr>
<td align="center">STAY</td>
<td align="center">播放完毕后停留在最后一帧</td>
</tr>
<tr>
<td align="center">LOOP</td>
<td align="center">正向循环播放</td>
</tr>
<tr>
<td align="center">PPONG</td>
<td align="center">正反往复播放，类似乒乓球</td>
</tr>
</tbody></table>
<h2 id="骨骼动画"><a href="#骨骼动画" class="headerlink" title="骨骼动画"></a>骨骼动画</h2><p>骨骼动画也称角色动画，主要用于表达生物或非生物体的感情和行为。角色的每个部件都被称为骨骼（Bone），连接骨骼的对象被称为关节（Joint），所有骨骼和关节的集合被称为骨架系统（Skeleton）。</p>
<p>osgAnimation 中使用派生自 Transform 的 Skeleton 和 Bone 来表达骨骼结构，其中 Skeleton 作为角色的根节点，需要承担更多的任务，是 Bone 的派生类。骨骼中每增加一个 Bone 就会自动增加一个动画更新回调。</p>
<h2 id="变形体动画"><a href="#变形体动画" class="headerlink" title="变形体动画"></a>变形体动画</h2><p>变形体动画（Morph Target Animation）又被称为逐顶点动画，是另一种常见的三维动画表现形式。它记录了一系列顶点位置的坐标和偏移，并在动画运行的每一帧中将顶点移动到新的位置，形成持续、平滑的运动效果。</p>
<p>变形体动画可以精确地表达一个物体，尤其是自然界中生物体的运动和变形过程。物体中定义的可变化顶点数越多，变形体动画就会越复杂，对计算机运算资源的消耗也越大，通常每帧中以 4000-9000 个顶点的位置变化为宜。</p>
<p>osgAnimation::MorphGeometry 类用于表达变形体动画，它继承自 osg::Geometry 类，采用 VBO 方式完成顶点数据的动态刷新。MorphGeometry 类使用构造函数传入原始几何体，并使用 addMorphTarget 函数来添加一个或多个变化目标，存在多个变化目标时，将依据它们的权重来影响变形的结果。最终还需要添加一个 UpdateMorph 动画回调来实现变形体动画的更新过程。</p>
<h2 id="渐进动画"><a href="#渐进动画" class="headerlink" title="渐进动画"></a>渐进动画</h2><p>渐进动画用于辅助为动画过程提供渐进加速或减速的效果，使动画效果更逼近物理世界。渐进动画处理器不受 osgAnimation 动画管理器的约束，也不存在回调函数，用户可以其它回调函数中定义并使用渐进动画处理器。可以在回调函数中加入以下代码，以获取渐进效果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion = </span><br><span class="line">    <span class="keyword">new</span> osgAnimation::InOutCubicMotion;</span><br><span class="line"></span><br><span class="line">_motion-&gt;<span class="built_in">update</span>( <span class="number">0.01</span> );<span class="comment">//渐进增加1/100</span></span><br><span class="line"><span class="type">float</span> alpha = _motion-&gt;<span class="built_in">getValue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在节点回调函数中动态调整物体透明度</span></span><br><span class="line">shape-&gt;<span class="built_in">setColor</span>( osg::<span class="built_in">Vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, alpha) );</span><br></pre></td></tr></table></figure>

<h2 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h2><p>纹理动画的基本原理是动态切换当前显示的图片，借助视觉暂留现象来实现连续播放的效果。OSG 中提供了 osg::ImageSequence 类用于播放纹理动画，首先预加载一系列纹理图片，然后在指定的时刻动态改变显示的图片，进而影响模型中物体所绑定的纹理对象，实现动画效果。现在，纹理动画通常被着色器代替。</p>
<h1 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h1><p>在 OSG 中，名字空间 osgPartible 内的类用来模拟粒子系统。osgParticle 采用 Billboard 和色彩融合技术生成粒子，能够高效地模拟粒子系统，生成非常真实的效果。</p>
<h2 id="粒子系统组成"><a href="#粒子系统组成" class="headerlink" title="粒子系统组成"></a>粒子系统组成</h2><p>构成一个粒子系统，需要以下模块：</p>
<ul>
<li>放射器（osgParticle::Emitter）：一个标准的放射器包括一个计数器、一个放置器和一个发射器，它为用户控制粒子系统中多个元素提供了一个标准机制。</li>
<li>粒子系统（osgParticle::ParticleSystem）：维护并管理一系列粒子的生成、更新、渲染和销毁。粒子系统类继承自 Drawable 类，用于控制粒子的渲染，通过 StateAttribute 可以控制其渲染属性。</li>
<li>粒子（osgParticle::Particle）：粒子系统的基本单元。同时具有物理属性和图像属性，形状可以是点（POINT）、四边形（QUAD）、四边形带（QUAD_TRIPSTRIP）、六角形（HEXAGON）或线（LINE）。每个粒子都有生命周期（秒），生命周期为负数的粒子可以存活无限长时间。粒子还具有大小（SIZE）、Alpha 值和颜色（COLOR）属性。每一组粒子都可以指定最大和最小值，粒子系统依据已经消耗的时间在粒子的最大值和最小值之间进行线性插值。</li>
<li>放置器（osgParticle::Placer）：设置粒子发射的初始位置，用户可以使用预定义的放置器或自定义自己的放置器。预定义的粒子放置器包括点放置器（所有粒子在同一点出生）、扇面放置器（所有粒子从指定中心点、半径和角度范围的扇面内出生）、多段放置器（粒子沿一系列点构成的线段出生）。</li>
<li>发射器（osgParticle::Shooter）：指定粒子的初始速度。RadialShooter 类允许用户指定一个速度范围以及弧度值表示的方向，方向由两个角度指定（theta 角是与 Z 轴的夹角，phi 角是与平面的夹角）。</li>
<li>计数器（osgParticle::Counter）：控制每一帧产生的粒子数，RandomRateCounter 类允许用户指定每帧产生粒子的最大和最小值。</li>
<li>粒子系统更新器（osgParticle::ParticleSystemUpdater）：用于自动更新粒子，将其置于场景中时，它会在拣选遍历中调用所有存活粒子的更新方法。</li>
<li>标准编程器（osgParticle::ModularProgram）：在单个粒子的生命周期中，用户可以使用 ModularProgram 实例控制粒子的位置，ModulaProgram 需要与 Operator 类对象组合使用。</li>
<li>操作器（osgParticle::Operator）：提供了控制粒子在其生命周期中的运动特性的方法。用户可以改变现有 Operator 类实例的参数或自定义 Operator 类。OSG 提供的 Operator 类包括 AccelOperator（加速度）、AngularAccelOperator（角加速度）、FluidFrictionOperator（空气阻力或流体操作）以及 ForceOperator（压力）。<br /></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[Root-根节点] --&gt; B[Program]</span><br><span class="line">A[Root-根节点] --&gt; C[Emitter-放射器]</span><br><span class="line"></span><br><span class="line">B --&gt; D[Operator]</span><br><span class="line">B --&gt; E[Modular-外部物理模拟操作]</span><br><span class="line"></span><br><span class="line">C --&gt; F[ParticleSystem-粒子系统属性]</span><br><span class="line">C --&gt; G&#123; &#125;</span><br><span class="line">C --&gt; H[Particle-粒子模板]</span><br><span class="line"></span><br><span class="line">G --&gt; I[Counter-计数器]</span><br><span class="line">G --&gt; J[Placer-放置器]</span><br><span class="line">G --&gt; K[Shooter-发射器]</span><br></pre></td></tr></table></figure>

<p>在 OSG 中已经定义了一些常见的特效模块，如 osgParticle :: ExplosionDebrisEffect（爆炸碎片）、osgParticle :: ExplosionEffect（爆炸模拟）、osgParticle :: SmokeEffect（烟雾模拟）、osgParticle::FireEffect（火光模拟）以及 osgParticle::PrecipitationEffect（雨雪模拟）。</p>
<h2 id="粒子系统使用"><a href="#粒子系统使用" class="headerlink" title="粒子系统使用"></a>粒子系统使用</h2><p>存在两种使用粒子系统方式，一种是 OSG 自定义好的粒子系统，另一种是自定义粒子系统。</p>
<p>预定义粒子系统的使用过程如下：</p>
<ul>
<li>创建预定义粒子系统模块对象，设置相应的参数；</li>
<li>将粒子系统作为子节点加入到场景节点中。<br /></li>
</ul>
<p>自定义粒子系统的使用过程如下：</p>
<ul>
<li>创建粒子系统（osgParticle::ParticleSystem），并将其加入到场景中，设置相应的材质、放射、光照等属性；</li>
<li>创建粒子模板（osgParticle::Particle），设置粒子模板的大小、颜色、生命周期、重量等参数，用于控制场景中每一个粒子的特性并将其关联到粒子系统；</li>
<li>创建粒子系统放射器（osgParticle::ModularEmmiter），标准的放射器包括计数器（Counter）、放置器（Placer）和发射器（Shooter）3 部分，设置相应的位置、形状、速度和方向等属性。</li>
<li>创建粒子系统编程器对象（osgParticle::Program），控制粒子在生命周期内的运动，一个标准的编程器对象包含各种操作器，如 osgParticle::AccelOperator 和 osgParticle::FluidFrictionOperator 等。</li>
<li>创建粒子系统更新器（osgParticle::ParticleSystemUpdater），用于管理每一帧中粒子的位置、速度和方向等参数。<br /></li>
</ul>
<h1 id="NodeKits"><a href="#NodeKits" class="headerlink" title="NodeKits"></a>NodeKits</h1><h2 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h2><p>凹凸贴图特效可以创建一个凹凸不平的表面效果，需要使用普通漫反射纹理和法线贴图（可以使用 nVIDIA 的法线贴图生成器制作）两种纹理来创建。</p>
<p>此外，还需要创建正切空间的基向量并将其关联到每个几何体上（这一步骤可以调用 BumpMapping::prepareChildren 方法来完成），Geometry 对象的漫反射颜色和法线贴图纹理都必须提前定义好对应的 UV 贴图。</p>
<h2 id="刻线特效"><a href="#刻线特效" class="headerlink" title="刻线特效"></a>刻线特效</h2><p>刻线特效（osgFX::Scribe）是一个双通道的特效，第一个通道以通常的方式渲染图形，第二个通道使用线框模式。用户设置好光照和材质之后，即可使用指定的颜色进行渲染。这个特效使用了 PolygonOffset 渲染属性类来避免多边形深度冲突（Z-fighting）的斑驳现象。</p>
<p>刻线特效的使用非常简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">osg::ref_ptr&lt;osgFX::Scribe&gt; sc = <span class="keyword">new</span> osgFX::<span class="built_in">Scribe</span>( );</span><br><span class="line">sc-&gt;<span class="built_in">setWireFrameColor</span>( osg::<span class="built_in">Vec4</span>() );</span><br><span class="line">sc-&gt;<span class="built_in">setWireFrameLineWidth</span>( );</span><br></pre></td></tr></table></figure>

<h2 id="DOFTransform"><a href="#DOFTransform" class="headerlink" title="DOFTransform"></a>DOFTransform</h2><p>DOFTransform 类是对 Multigen 中 DOF 操作的一个封装，主要用于机械仿真中的机械运动控制，如履带的运动和机器手臂的运动等。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>王锐, 钱学雷. OpenSceneGraph 三维渲染引擎设计与实践[M]. 清华大学出版社, 2009.</li>
<li>肖鹏, 刘更代, 徐明亮. OpenSceneGraph 三维渲染引擎编程指南[M]. 清华大学出版社, 2010.</li>
</ul>

  </div>
</section>

		


<footer class="footer">
  <div class="content container">
      <!--// row -->
      <div class="row">
          <div class="col-xs-6">
            
              <img class="footer-logo" src="img/logo.png" alt="Shen Tongda">
            
          </div>
          <div class="col-xs-6 text-right sm-text-left">
              <p class="margin-b-0">
                <a class="fweight-700" target="_blank" rel="noopener" href="https://hexo.io/">Hexo.io</a> adaptation by <a class="fweight-700" target="_blank" rel="noopener" href="https://molavec.com">Molavec</a>.
                <br>
                <br>
                <a class="fweight-700" target="_blank" rel="noopener" href="https://keenthemes.com/preview/aircv/">Aircv</a>. Theme Powered by: <a class="fweight-700" target="_blank" rel="noopener" href="https://www.keenthemes.com/">KeenThemes.com</a>.
            </p>
          </div>
      </div>
      <!--// end row -->
  </div>
</footer>
		<!-- Back To Top -->
<a href="javascript:void(0);" class="js-back-to-top back-to-top">Top</a>

<!-- JAVASCRIPTS(Load javascripts at bottom, this will reduce page load time) -->
<!-- CORE PLUGINS -->
<script src="/vendor/jquery.min.js" type="text/javascript"></script>
<script src="/vendor/jquery-migrate.min.js" type="text/javascript"></script>
<script src="/vendor/bootstrap/js/bootstrap.min.js" type="text/javascript"></script>

<!-- PAGE LEVEL PLUGINS -->
<script src="/vendor/jquery.easing.js" type="text/javascript"></script>
<script src="/vendor/jquery.back-to-top.js" type="text/javascript"></script>
<script src="/vendor/jquery.wow.min.js" type="text/javascript"></script>
<script src="/vendor/jquery.parallax.min.js" type="text/javascript"></script>
<script src="/vendor/jquery.appear.js" type="text/javascript"></script>
<script src="/vendor/masonry/jquery.masonry.pkgd.min.js" type="text/javascript"></script>
<script src="/vendor/masonry/imagesloaded.pkgd.min.js" type="text/javascript"></script>

<!-- PAGE LEVEL SCRIPTS -->



<script src="/js/layout.js"></script>
<script src="/js/components/progress-bar.js"></script>
<script src="/js/components/masonry.js"></script>
<script src="/js/components/wow.js"></script>


		

  </body>
</html>